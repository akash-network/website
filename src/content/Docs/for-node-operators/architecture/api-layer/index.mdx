---
categories: ["For Node Operators"]
tags: ["Architecture", "API", "gRPC", "REST", "RPC"]
weight: 4
title: "API Layer"
linkTitle: "API Layer"
description: "Complete guide to Akash node APIs: gRPC, REST, and RPC endpoints"
---

import CodeTabs from "@/components/docs/CodeTabs";

The API Layer provides interfaces for querying blockchain state and submitting transactions. Akash nodes expose three types of APIs: gRPC (primary), REST (gRPC-Gateway), and CometBFT RPC.

---

## API Architecture

```
+---------------------------------------------------------------+
|                        API Layer                              |
|                                                               |
|  +-----------------+  +-----------------+  +----------------+ |
|  |     gRPC        |  |      REST       |  |   CometBFT     | |
|  |   (Port 9090)   |  |   (Port 1317)   |  |      RPC       | |
|  |                 |  |                 |  |  (Port 26657)  | |
|  |  Native Binary  |  |  HTTP Gateway   |  |                | |
|  |  Protocol Buf   |  | (gRPC-Gateway)  |  |  Blockchain    | |
|  |  Streaming      |  |   JSON/HTTP     |  |    Queries     | |
|  +-----------------+  +-----------------+  +----------------+ |
|          |                    |                    |          |
|          +--------------------+--------------------+          |
|                               |                               |
+---------------------------------------------------------------+
                                |
                       Application State
                    (Keepers & State Store)
```

---

## gRPC API

**gRPC** is the primary API for querying state and submitting transactions.

### Why gRPC?

**Advantages:**
- **High Performance** - Binary protocol (Protocol Buffers)
- **Type Safety** - Strong typing via protobuf
- **Streaming** - Real-time updates
- **Code Generation** - Auto-generate clients
- **HTTP/2** - Multiplexing, compression

**Default Port:** `9090`

### Service Types

**1. Query Services** - Read-only state queries
**2. Msg Services** - Submit transactions
**3. Reflection Services** - Service discovery

---

## gRPC Query Services

### Cosmos SDK Queries

**Auth Module:**
```
/cosmos.auth.v1beta1.Query/Account
/cosmos.auth.v1beta1.Query/Accounts
/cosmos.auth.v1beta1.Query/AccountInfo
/cosmos.auth.v1beta1.Query/Params
```

**Bank Module:**
```
/cosmos.bank.v1beta1.Query/Balance
/cosmos.bank.v1beta1.Query/AllBalances
/cosmos.bank.v1beta1.Query/TotalSupply
/cosmos.bank.v1beta1.Query/SupplyOf
/cosmos.bank.v1beta1.Query/DenomMetadata
```

**Staking Module:**
```
/cosmos.staking.v1beta1.Query/Validators
/cosmos.staking.v1beta1.Query/Validator
/cosmos.staking.v1beta1.Query/Delegation
/cosmos.staking.v1beta1.Query/Delegations
/cosmos.staking.v1beta1.Query/UnbondingDelegation
/cosmos.staking.v1beta1.Query/Pool
```

**Distribution Module:**
```
/cosmos.distribution.v1beta1.Query/Rewards
/cosmos.distribution.v1beta1.Query/DelegationTotalRewards
/cosmos.distribution.v1beta1.Query/ValidatorCommission
/cosmos.distribution.v1beta1.Query/CommunityPool
```

**Gov Module:**
```
/cosmos.gov.v1.Query/Proposal
/cosmos.gov.v1.Query/Proposals
/cosmos.gov.v1.Query/Vote
/cosmos.gov.v1.Query/Votes
/cosmos.gov.v1.Query/Params
/cosmos.gov.v1.Query/Deposits
```

---

### Akash Module Queries

**Deployment Module:**
```
/akash.deployment.v1.Query/Deployments
/akash.deployment.v1.Query/Deployment
/akash.deployment.v1.Query/Group
```

**Market Module:**
```
/akash.market.v1.Query/Orders
/akash.market.v1.Query/Order
/akash.market.v1.Query/Bids
/akash.market.v1.Query/Bid
/akash.market.v1.Query/Leases
/akash.market.v1.Query/Lease
```

**Provider Module:**
```
/akash.provider.v1.Query/Providers
/akash.provider.v1.Query/Provider
```

**Audit Module:**
```
/akash.audit.v1.Query/AllProvidersAttributes
/akash.audit.v1.Query/ProviderAttributes
/akash.audit.v1.Query/ProviderAuditorAttributes
/akash.audit.v1.Query/AuditorAttributes
```

**Cert Module:**
```
/akash.cert.v1.Query/Certificates
```

**Escrow Module:**
```
/akash.escrow.v1.Query/Accounts
/akash.escrow.v1.Query/Payments
```

---

## gRPC Client Examples

### Query Providers

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `# Using grpcurl (install: go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest)
grpcurl -plaintext localhost:9090 \\
  akash.provider.v1.Query/Providers`
    },
    {
      language: "go",
      code: `package main

import (
    "context"
    "fmt"
    "log"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    providertypes "pkg.akt.dev/go/node/provider/v1"
)

func main() {
    // Connect to gRPC server
    conn, err := grpc.Dial(
        "localhost:9090",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        log.Fatalf("Failed to connect: %v", err)
    }
    defer conn.Close()
    
    // Create query client
    client := providertypes.NewQueryClient(conn)
    
    // Query all providers
    res, err := client.Providers(
        context.Background(),
        &providertypes.QueryProvidersRequest{},
    )
    if err != nil {
        log.Fatalf("Query failed: %v", err)
    }
    
    // Print results
    for _, provider := range res.Providers {
        fmt.Printf("Provider: %s\\n", provider.Owner)
        fmt.Printf("Host URI: %s\\n", provider.HostUri)
        fmt.Printf("Attributes: %d\\n", len(provider.Attributes))
        fmt.Println("---")
    }
}`
    },
    {
      language: "typescript",
      code: `import { createProtobufRpcClient, QueryClient } from "@cosmjs/stargate";
import { Tendermint37Client } from "@cosmjs/tendermint-rpc";
import { QueryClientImpl } from "@akashnetwork/akash-api/akash/provider/v1";

async function queryProviders() {
  // Connect to RPC endpoint
  const tmClient = await Tendermint37Client.connect("http://localhost:26657");
  
  // Create query client
  const queryClient = new QueryClient(tmClient);
  const rpcClient = createProtobufRpcClient(queryClient);
  
  // Create provider query client
  const providerQueryClient = new QueryClientImpl(rpcClient);
  
  // Query all providers
  const response = await providerQueryClient.Providers({});
  
  // Print results
  response.providers.forEach((provider) => {
    console.log(\`Provider: \${provider.owner}\`);
    console.log(\`Host URI: \${provider.hostUri}\`);
    console.log(\`Attributes: \${provider.attributes.length}\`);
    console.log("---");
  });
}

queryProviders().catch(console.error);`
    }
  ]}
/>

### Query Specific Deployment

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `grpcurl -plaintext \\
  -d '{
    "id": {
      "owner": "akash1...",
      "dseq": "123"
    }
  }' \\
  localhost:9090 \\
  akash.deployment.v1.Query/Deployment`
    },
    {
      language: "go",
      code: `package main

import (
    "context"
    "fmt"
    "log"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    deploymenttypes "pkg.akt.dev/go/node/deployment/v1"
)

func main() {
    conn, err := grpc.Dial(
        "localhost:9090",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()
    
    client := deploymenttypes.NewQueryClient(conn)
    
    // Query specific deployment
    res, err := client.Deployment(
        context.Background(),
        &deploymenttypes.QueryDeploymentRequest{
            Id: deploymenttypes.DeploymentID{
                Owner: "akash1...",
                Dseq:  123,
            },
        },
    )
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Deployment State: %s\\n", res.Deployment.State)
    fmt.Printf("Created At: %d\\n", res.Deployment.CreatedAt)
}`
    },
    {
      language: "typescript",
      code: `import { createProtobufRpcClient, QueryClient } from "@cosmjs/stargate";
import { Tendermint37Client } from "@cosmjs/tendermint-rpc";
import { QueryClientImpl, DeploymentID } from "@akashnetwork/akash-api/akash/deployment/v1";

async function queryDeployment(owner: string, dseq: number) {
  const tmClient = await Tendermint37Client.connect("http://localhost:26657");
  const queryClient = new QueryClient(tmClient);
  const rpcClient = createProtobufRpcClient(queryClient);
  const deploymentQueryClient = new QueryClientImpl(rpcClient);
  
  const id: DeploymentID = {
    owner: owner,
    dseq: BigInt(dseq),
  };
  
  const response = await deploymentQueryClient.Deployment({ id });
  
  console.log(\`Deployment State: \${response.deployment.state}\`);
  console.log(\`Created At: \${response.deployment.createdAt}\`);
}

queryDeployment("akash1...", 123).catch(console.error);`
    }
  ]}
/>

---

## REST API (gRPC-Gateway)

REST API is automatically generated from gRPC services using **gRPC-Gateway**.

**Default Port:** `1317`

**Enable REST API:**
```toml
# app.toml
[api]
enable = true
address = "tcp://0.0.0.0:1317"
```

### REST Endpoints

**Format:**
```
GET  /akash/{module}/{version}/{resource}
POST /cosmos/tx/v1beta1/txs
```

---

### Cosmos SDK REST Endpoints

**Auth:**
```
GET /cosmos/auth/v1beta1/accounts/{address}
GET /cosmos/auth/v1beta1/accounts
```

**Bank:**
```
GET /cosmos/bank/v1beta1/balances/{address}
GET /cosmos/bank/v1beta1/balances/{address}/by_denom
GET /cosmos/bank/v1beta1/supply
```

**Staking:**
```
GET /cosmos/staking/v1beta1/validators
GET /cosmos/staking/v1beta1/validators/{validator_addr}
GET /cosmos/staking/v1beta1/delegations/{delegator_addr}
GET /cosmos/staking/v1beta1/validators/{validator_addr}/delegations
```

**Gov:**
```
GET /cosmos/gov/v1/proposals
GET /cosmos/gov/v1/proposals/{proposal_id}
GET /cosmos/gov/v1/proposals/{proposal_id}/votes
GET /cosmos/gov/v1/proposals/{proposal_id}/deposits
```

---

### Akash REST Endpoints

**Deployment:**
```
GET /akash/deployment/v1/deployments/list
GET /akash/deployment/v1/deployments/info
  ?id.owner={owner}&id.dseq={dseq}
```

**Market:**
```
GET /akash/market/v1/orders/list
GET /akash/market/v1/orders/info
  ?id.owner={owner}&id.dseq={dseq}&id.gseq={gseq}&id.oseq={oseq}

GET /akash/market/v1/bids/list
GET /akash/market/v1/leases/list
```

**Provider:**
```
GET /akash/provider/v1/providers
GET /akash/provider/v1/providers/{owner}
```

**Audit:**
```
GET /akash/audit/v1/attributes/list
```

---

### REST Examples

#### Query Account Balance

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `curl http://localhost:1317/cosmos/bank/v1beta1/balances/akash1...`
    },
    {
      language: "go",
      code: `package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
)

type Balance struct {
    Denom  string \`json:"denom"\`
    Amount string \`json:"amount"\`
}

type BalanceResponse struct {
    Balances []Balance \`json:"balances"\`
}

func main() {
    address := "akash1..."
    url := fmt.Sprintf("http://localhost:1317/cosmos/bank/v1beta1/balances/%s", address)
    
    resp, err := http.Get(url)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatal(err)
    }
    
    var result BalanceResponse
    if err := json.Unmarshal(body, &result); err != nil {
        log.Fatal(err)
    }
    
    for _, balance := range result.Balances {
        fmt.Printf("%s: %s\\n", balance.Denom, balance.Amount)
    }
}`
    },
    {
      language: "typescript",
      code: `interface Balance {
  denom: string;
  amount: string;
}

interface BalanceResponse {
  balances: Balance[];
}

async function queryBalance(address: string): Promise<void> {
  const url = \`http://localhost:1317/cosmos/bank/v1beta1/balances/\${address}\`;
  
  const response = await fetch(url);
  const data: BalanceResponse = await response.json();
  
  data.balances.forEach((balance) => {
    console.log(\`\${balance.denom}: \${balance.amount}\`);
  });
}

queryBalance("akash1...").catch(console.error);`
    }
  ]}
/>

**Response:**
```json
{
  "balances": [
    {
      "denom": "uakt",
      "amount": "1000000000"
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "1"
  }
}
```

#### Query Providers

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `curl "http://localhost:1317/akash/provider/v1/providers"`
    },
    {
      language: "go",
      code: `package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
)

type Attribute struct {
    Key   string \`json:"key"\`
    Value string \`json:"value"\`
}

type Provider struct {
    Owner      string      \`json:"owner"\`
    HostURI    string      \`json:"host_uri"\`
    Attributes []Attribute \`json:"attributes"\`
}

type ProvidersResponse struct {
    Providers []Provider \`json:"providers"\`
}

func main() {
    url := "http://localhost:1317/akash/provider/v1/providers"
    
    resp, err := http.Get(url)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatal(err)
    }
    
    var result ProvidersResponse
    if err := json.Unmarshal(body, &result); err != nil {
        log.Fatal(err)
    }
    
    for _, provider := range result.Providers {
        fmt.Printf("Provider: %s\\n", provider.Owner)
        fmt.Printf("Host: %s\\n", provider.HostURI)
        fmt.Printf("Attributes: %d\\n", len(provider.Attributes))
        fmt.Println("---")
    }
}`
    },
    {
      language: "typescript",
      code: `interface Attribute {
  key: string;
  value: string;
}

interface Provider {
  owner: string;
  host_uri: string;
  attributes: Attribute[];
}

interface ProvidersResponse {
  providers: Provider[];
}

async function queryProviders(): Promise<void> {
  const url = "http://localhost:1317/akash/provider/v1/providers";
  
  const response = await fetch(url);
  const data: ProvidersResponse = await response.json();
  
  data.providers.forEach((provider) => {
    console.log(\`Provider: \${provider.owner}\`);
    console.log(\`Host: \${provider.host_uri}\`);
    console.log(\`Attributes: \${provider.attributes.length}\`);
    console.log("---");
  });
}

queryProviders().catch(console.error);`
    }
  ]}
/>

---

## Submit Transactions

### Via gRPC

**1. Build transaction:**
```go
msg := &deploymenttypes.MsgCreateDeployment{
    Id: deploymenttypes.DeploymentID{
        Owner: owner,
        Dseq:  dseq,
    },
    Groups: groups,
    Version: version,
    Deposit: deposit,
}

txBuilder := txConfig.NewTxBuilder()
txBuilder.SetMsgs(msg)
txBuilder.SetGasLimit(200000)
txBuilder.SetFeeAmount(sdk.NewCoins(
    sdk.NewCoin("uakt", sdk.NewInt(5000)),
))
```

**2. Sign transaction:**
```go
signerData := authsigning.SignerData{
    ChainID:       chainID,
    AccountNumber: accNum,
    Sequence:      seq,
}

sigV2, err := tx.SignWithPrivKey(
    txConfig.SignModeHandler(),
    signerData,
    txBuilder,
    privKey,
    txConfig,
    seq,
)
```

**3. Broadcast:**
```go
txBytes, err := txConfig.TxEncoder()(txBuilder.GetTx())

broadcastReq := &txtypes.BroadcastTxRequest{
    TxBytes: txBytes,
    Mode:    txtypes.BroadcastMode_BROADCAST_MODE_SYNC,
}

client := txtypes.NewServiceClient(conn)
res, err := client.BroadcastTx(ctx, broadcastReq)
```

---

### Via REST

**Endpoint:**
```
POST /cosmos/tx/v1beta1/txs
```

**Request body:**
```json
{
  "tx_bytes": "base64_encoded_tx",
  "mode": "BROADCAST_MODE_SYNC"
}
```

**Broadcast modes:**
- `BROADCAST_MODE_SYNC` - Wait for CheckTx
- `BROADCAST_MODE_ASYNC` - Return immediately
- `BROADCAST_MODE_BLOCK` - Wait for block inclusion (deprecated)

---

## CometBFT RPC

Low-level blockchain queries via CometBFT RPC.

**Default Port:** `26657`

**Enable RPC:**
```toml
# config.toml
[rpc]
laddr = "tcp://0.0.0.0:26657"
```

---

### Common RPC Endpoints

**Node Status:**
```
GET /status
```

**Response:**
```json
{
  "node_info": {
    "protocol_version": {...},
    "id": "node_id",
    "network": "akashnet-2",
    "version": "0.38.0"
  },
  "sync_info": {
    "latest_block_hash": "ABC123...",
    "latest_block_height": "12345678",
    "latest_block_time": "2024-01-01T00:00:00Z",
    "catching_up": false
  },
  "validator_info": {
    "address": "validator_address",
    "pub_key": {...},
    "voting_power": "1000000"
  }
}
```

**Get Block:**
```
GET /block?height=12345
```

**Get Block by Hash:**
```
GET /block_by_hash?hash=0x...
```

**Get Latest Block:**
```
GET /block
```

**Get Blockchain Info:**
```
GET /blockchain?minHeight=1&maxHeight=100
```

**Get Transaction:**
```
GET /tx?hash=0x...&prove=true
```

**Search Transactions:**
```
GET /tx_search?query="tx.height>1000"&prove=false
```

**Get Validators:**
```
GET /validators?height=12345
```

**Get Consensus State:**
```
GET /consensus_state
```

**Get Net Info:**
```
GET /net_info
```

**Get Genesis:**
```
GET /genesis
```

---

### RPC Examples

#### Check Node Status

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `curl http://localhost:26657/status | jq`
    },
    {
      language: "go",
      code: `package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
)

type SyncInfo struct {
    LatestBlockHeight string \`json:"latest_block_height"\`
    LatestBlockTime   string \`json:"latest_block_time"\`
    CatchingUp        bool   \`json:"catching_up"\`
}

type NodeInfo struct {
    Network string \`json:"network"\`
    Version string \`json:"version"\`
}

type StatusResult struct {
    NodeInfo NodeInfo \`json:"node_info"\`
    SyncInfo SyncInfo \`json:"sync_info"\`
}

type StatusResponse struct {
    Result StatusResult \`json:"result"\`
}

func main() {
    url := "http://localhost:26657/status"
    
    resp, err := http.Get(url)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatal(err)
    }
    
    var result StatusResponse
    if err := json.Unmarshal(body, &result); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Network: %s\\n", result.Result.NodeInfo.Network)
    fmt.Printf("Version: %s\\n", result.Result.NodeInfo.Version)
    fmt.Printf("Latest Height: %s\\n", result.Result.SyncInfo.LatestBlockHeight)
    fmt.Printf("Catching Up: %v\\n", result.Result.SyncInfo.CatchingUp)
}`
    },
    {
      language: "typescript",
      code: `interface SyncInfo {
  latest_block_height: string;
  latest_block_time: string;
  catching_up: boolean;
}

interface NodeInfo {
  network: string;
  version: string;
}

interface StatusResult {
  node_info: NodeInfo;
  sync_info: SyncInfo;
}

interface StatusResponse {
  result: StatusResult;
}

async function checkNodeStatus(): Promise<void> {
  const url = "http://localhost:26657/status";
  
  const response = await fetch(url);
  const data: StatusResponse = await response.json();
  
  console.log(\`Network: \${data.result.node_info.network}\`);
  console.log(\`Version: \${data.result.node_info.version}\`);
  console.log(\`Latest Height: \${data.result.sync_info.latest_block_height}\`);
  console.log(\`Catching Up: \${data.result.sync_info.catching_up}\`);
}

checkNodeStatus().catch(console.error);`
    }
  ]}
/>

#### Get Block by Height

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `curl "http://localhost:26657/block?height=12345" | jq`
    },
    {
      language: "go",
      code: `package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
)

type BlockHeader struct {
    Height  string \`json:"height"\`
    Time    string \`json:"time"\`
    ChainID string \`json:"chain_id"\`
}

type Block struct {
    Header BlockHeader \`json:"header"\`
}

type BlockResult struct {
    Block Block \`json:"block"\`
}

type BlockResponse struct {
    Result BlockResult \`json:"result"\`
}

func main() {
    height := "12345"
    url := fmt.Sprintf("http://localhost:26657/block?height=%s", height)
    
    resp, err := http.Get(url)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatal(err)
    }
    
    var result BlockResponse
    if err := json.Unmarshal(body, &result); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Height: %s\\n", result.Result.Block.Header.Height)
    fmt.Printf("Time: %s\\n", result.Result.Block.Header.Time)
    fmt.Printf("Chain ID: %s\\n", result.Result.Block.Header.ChainID)
}`
    },
    {
      language: "typescript",
      code: `interface BlockHeader {
  height: string;
  time: string;
  chain_id: string;
}

interface Block {
  header: BlockHeader;
}

interface BlockResult {
  block: Block;
}

interface BlockResponse {
  result: BlockResult;
}

async function getBlock(height: number): Promise<void> {
  const url = \`http://localhost:26657/block?height=\${height}\`;
  
  const response = await fetch(url);
  const data: BlockResponse = await response.json();
  
  console.log(\`Height: \${data.result.block.header.height}\`);
  console.log(\`Time: \${data.result.block.header.time}\`);
  console.log(\`Chain ID: \${data.result.block.header.chain_id}\`);
}

getBlock(12345).catch(console.error);`
    }
  ]}
/>

---

## WebSocket Subscriptions

Subscribe to real-time blockchain events.

**Endpoint:**
```
ws://localhost:26657/websocket
```

### Subscribe to Events

**New blocks:**
```json
{
  "jsonrpc": "2.0",
  "method": "subscribe",
  "params": {
    "query": "tm.event='NewBlock'"
  },
  "id": 1
}
```

**New transactions:**
```json
{
  "jsonrpc": "2.0",
  "method": "subscribe",
  "params": {
    "query": "tm.event='Tx'"
  },
  "id": 2
}
```

**Custom events:**
```json
{
  "jsonrpc": "2.0",
  "method": "subscribe",
  "params": {
    "query": "akash.v1.EventLeaseCreated.id.owner='akash1...'"
  },
  "id": 3
}
```

### WebSocket Example

<CodeTabs
  client:load
  examples={[
    {
      language: "bash",
      label: "cURL",
      code: `# Using websocat (install: cargo install websocat)
echo '{"jsonrpc":"2.0","method":"subscribe","params":{"query":"tm.event='\\''NewBlock'\\''"},"id":1}' | \\
  websocat ws://localhost:26657/websocket`
    },
    {
      language: "go",
      code: `package main

import (
    "encoding/json"
    "fmt"
    "log"
    
    "github.com/gorilla/websocket"
)

type SubscribeRequest struct {
    JSONRPC string                 \`json:"jsonrpc"\`
    Method  string                 \`json:"method"\`
    Params  map[string]interface{} \`json:"params"\`
    ID      int                    \`json:"id"\`
}

func main() {
    // Connect to WebSocket
    conn, _, err := websocket.DefaultDialer.Dial(
        "ws://localhost:26657/websocket",
        nil,
    )
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()
    
    // Subscribe to new blocks
    req := SubscribeRequest{
        JSONRPC: "2.0",
        Method:  "subscribe",
        Params: map[string]interface{}{
            "query": "tm.event='NewBlock'",
        },
        ID: 1,
    }
    
    if err := conn.WriteJSON(req); err != nil {
        log.Fatal(err)
    }
    
    // Listen for events
    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            log.Fatal(err)
        }
        
        var event map[string]interface{}
        if err := json.Unmarshal(message, &event); err != nil {
            log.Fatal(err)
        }
        
        fmt.Printf("New block event: %+v\\n", event)
    }
}`
    },
    {
      language: "typescript",
      code: `import WebSocket from 'ws';

interface SubscribeRequest {
  jsonrpc: string;
  method: string;
  params: { query: string };
  id: number;
}

interface BlockEvent {
  result: {
    data: {
      value: {
        block: {
          header: {
            height: string;
            time: string;
          };
        };
      };
    };
  };
}

function subscribeToBlocks(): void {
  const ws = new WebSocket('ws://localhost:26657/websocket');
  
  ws.on('open', () => {
    console.log('Connected to WebSocket');
    
    // Subscribe to new blocks
    const request: SubscribeRequest = {
      jsonrpc: '2.0',
      method: 'subscribe',
      params: { query: "tm.event='NewBlock'" },
      id: 1
    };
    
    ws.send(JSON.stringify(request));
  });
  
  ws.on('message', (data: WebSocket.Data) => {
    const event: BlockEvent = JSON.parse(data.toString());
    
    if (event.result && event.result.data) {
      const header = event.result.data.value.block.header;
      console.log(\`New block: \${header.height} at \${header.time}\`);
    }
  });
  
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
  
  ws.on('close', () => {
    console.log('WebSocket connection closed');
  });
}

subscribeToBlocks();`
    }
  ]}
/>

---

## API Configuration

### gRPC Configuration

**app.toml:**
```toml
[grpc]
enable = true
address = "0.0.0.0:9090"
```

### REST Configuration

**app.toml:**
```toml
[api]
enable = true
address = "tcp://0.0.0.0:1317"
swagger = true
enabled-unsafe-cors = false
```

### RPC Configuration

**config.toml:**
```toml
[rpc]
laddr = "tcp://0.0.0.0:26657"

# Maximum number of simultaneous connections
max_open_connections = 900

# Maximum number of subscription clients
max_subscription_clients = 100

# CORS allowed origins
cors_allowed_origins = []
```

---

## Security Considerations

### Production API Setup

**1. Use Reverse Proxy**

```nginx
server {
  listen 443 ssl;
  server_name api.example.com;
  
  location / {
    proxy_pass http://localhost:1317;
  }
}
```

**2. Rate Limiting**

```nginx
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

location / {
  limit_req zone=api burst=20;
  proxy_pass http://localhost:1317;
}
```

**3. Authentication**

Add API keys or OAuth for public endpoints.

**4. CORS Configuration**

```toml
[api]
enabled-unsafe-cors = false  # Disable in production
```

**5. Firewall Rules**

```bash
# Only allow from specific IPs
ufw allow from 1.2.3.4 to any port 9090
ufw allow from 1.2.3.4 to any port 1317
```

---

## Public RPC Nodes

**Trusted community RPC nodes:**

```
https://rpc.akashnet.net:443
https://rpc.akash.forbole.com:443
https://rpc-akash.ecostake.com:443
https://akash-rpc.polkachu.com:443
https://akash.c29r3.xyz:443/rpc
```

**Latest list:**
```bash
curl https://raw.githubusercontent.com/akash-network/net/main/mainnet/rpc-nodes.txt
```

---

## Swagger/OpenAPI Documentation

**Enable Swagger UI:**
```toml
[api]
swagger = true
```

**Access Swagger:**
```
http://localhost:1317/swagger/
```

**OpenAPI spec:**
- [Akash API Swagger](https://github.com/akash-network/akash-api/blob/main/docs/swagger-ui/swagger.yaml)

---

## Additional Resources

- [gRPC Documentation](https://grpc.io/docs/)
- [CometBFT RPC Reference](https://docs.cometbft.com/v0.38/rpc/)
- [Cosmos SDK gRPC Docs](https://docs.cosmos.network/main/build/building-apps/grpc)
- [Akash API Repository](https://github.com/akash-network/akash-api)
- [Protocol Buffer Definitions](https://buf.build/akash-network)

